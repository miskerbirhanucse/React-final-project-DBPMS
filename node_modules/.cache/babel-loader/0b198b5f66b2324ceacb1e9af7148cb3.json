{"ast":null,"code":"/*\r\n Copyright 2012-2015, Yahoo Inc.\r\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\r\n */\n'use strict';\n\nconst percent = require('./percent');\n\nconst dataProperties = require('./data-properties');\n\nconst {\n  CoverageSummary\n} = require('./coverage-summary'); // returns a data object that represents empty coverage\n\n\nfunction emptyCoverage(filePath) {\n  return {\n    path: filePath,\n    statementMap: {},\n    fnMap: {},\n    branchMap: {},\n    s: {},\n    f: {},\n    b: {}\n  };\n} // asserts that a data object \"looks like\" a coverage object\n\n\nfunction assertValidObject(obj) {\n  const valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;\n\n  if (!valid) {\n    throw new Error('Invalid file coverage object, missing keys, found:' + Object.keys(obj).join(','));\n  }\n}\n/**\r\n * provides a read-only view of coverage for a single file.\r\n * The deep structure of this object is documented elsewhere. It has the following\r\n * properties:\r\n *\r\n * * `path` - the file path for which coverage is being tracked\r\n * * `statementMap` - map of statement locations keyed by statement index\r\n * * `fnMap` - map of function metadata keyed by function index\r\n * * `branchMap` - map of branch metadata keyed by branch index\r\n * * `s` - hit counts for statements\r\n * * `f` - hit count for functions\r\n * * `b` - hit count for branches\r\n */\n\n\nclass FileCoverage {\n  /**\r\n   * @constructor\r\n   * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\r\n   * and empty coverage object with the specified file path or a data object that\r\n   * has all the required properties for a file coverage object.\r\n   */\n  constructor(pathOrObj) {\n    if (!pathOrObj) {\n      throw new Error('Coverage must be initialized with a path or an object');\n    }\n\n    if (typeof pathOrObj === 'string') {\n      this.data = emptyCoverage(pathOrObj);\n    } else if (pathOrObj instanceof FileCoverage) {\n      this.data = pathOrObj.data;\n    } else if (typeof pathOrObj === 'object') {\n      this.data = pathOrObj;\n    } else {\n      throw new Error('Invalid argument to coverage constructor');\n    }\n\n    assertValidObject(this.data);\n  }\n  /**\r\n   * returns computed line coverage from statement coverage.\r\n   * This is a map of hits keyed by line number in the source.\r\n   */\n\n\n  getLineCoverage() {\n    const statementMap = this.data.statementMap;\n    const statements = this.data.s;\n    const lineMap = Object.create(null);\n    Object.entries(statements).forEach(([st, count]) => {\n      /* istanbul ignore if: is this even possible? */\n      if (!statementMap[st]) {\n        return;\n      }\n\n      const {\n        line\n      } = statementMap[st].start;\n      const prevVal = lineMap[line];\n\n      if (prevVal === undefined || prevVal < count) {\n        lineMap[line] = count;\n      }\n    });\n    return lineMap;\n  }\n  /**\r\n   * returns an array of uncovered line numbers.\r\n   * @returns {Array} an array of line numbers for which no hits have been\r\n   *  collected.\r\n   */\n\n\n  getUncoveredLines() {\n    const lc = this.getLineCoverage();\n    const ret = [];\n    Object.entries(lc).forEach(([l, hits]) => {\n      if (hits === 0) {\n        ret.push(l);\n      }\n    });\n    return ret;\n  }\n  /**\r\n   * returns a map of branch coverage by source line number.\r\n   * @returns {Object} an object keyed by line number. Each object\r\n   * has a `covered`, `total` and `coverage` (percentage) property.\r\n   */\n\n\n  getBranchCoverageByLine() {\n    const branchMap = this.branchMap;\n    const branches = this.b;\n    const ret = {};\n    Object.entries(branchMap).forEach(([k, map]) => {\n      const line = map.line || map.loc.start.line;\n      const branchData = branches[k];\n      ret[line] = ret[line] || [];\n      ret[line].push(...branchData);\n    });\n    Object.entries(ret).forEach(([k, dataArray]) => {\n      const covered = dataArray.filter(item => item > 0);\n      const coverage = covered.length / dataArray.length * 100;\n      ret[k] = {\n        covered: covered.length,\n        total: dataArray.length,\n        coverage\n      };\n    });\n    return ret;\n  }\n  /**\r\n   * return a JSON-serializable POJO for this file coverage object\r\n   */\n\n\n  toJSON() {\n    return this.data;\n  }\n  /**\r\n   * merges a second coverage object into this one, updating hit counts\r\n   * @param {FileCoverage} other - the coverage object to be merged into this one.\r\n   *  Note that the other object should have the same structure as this one (same file).\r\n   */\n\n\n  merge(other) {\n    if (other.all === true) {\n      return;\n    }\n\n    if (this.all === true) {\n      this.data = other.data;\n      return;\n    }\n\n    Object.entries(other.s).forEach(([k, v]) => {\n      this.data.s[k] += v;\n    });\n    Object.entries(other.f).forEach(([k, v]) => {\n      this.data.f[k] += v;\n    });\n    Object.entries(other.b).forEach(([k, v]) => {\n      let i;\n      const retArray = this.data.b[k];\n      /* istanbul ignore if: is this even possible? */\n\n      if (!retArray) {\n        this.data.b[k] = v;\n        return;\n      }\n\n      for (i = 0; i < retArray.length; i += 1) {\n        retArray[i] += v[i];\n      }\n    });\n  }\n\n  computeSimpleTotals(property) {\n    let stats = this[property];\n\n    if (typeof stats === 'function') {\n      stats = stats.call(this);\n    }\n\n    const ret = {\n      total: Object.keys(stats).length,\n      covered: Object.values(stats).filter(v => !!v).length,\n      skipped: 0\n    };\n    ret.pct = percent(ret.covered, ret.total);\n    return ret;\n  }\n\n  computeBranchTotals() {\n    const stats = this.b;\n    const ret = {\n      total: 0,\n      covered: 0,\n      skipped: 0\n    };\n    Object.values(stats).forEach(branches => {\n      ret.covered += branches.filter(hits => hits > 0).length;\n      ret.total += branches.length;\n    });\n    ret.pct = percent(ret.covered, ret.total);\n    return ret;\n  }\n  /**\r\n   * resets hit counts for all statements, functions and branches\r\n   * in this coverage object resulting in zero coverage.\r\n   */\n\n\n  resetHits() {\n    const statements = this.s;\n    const functions = this.f;\n    const branches = this.b;\n    Object.keys(statements).forEach(s => {\n      statements[s] = 0;\n    });\n    Object.keys(functions).forEach(f => {\n      functions[f] = 0;\n    });\n    Object.keys(branches).forEach(b => {\n      branches[b].fill(0);\n    });\n  }\n  /**\r\n   * returns a CoverageSummary for this file coverage object\r\n   * @returns {CoverageSummary}\r\n   */\n\n\n  toSummary() {\n    const ret = {};\n    ret.lines = this.computeSimpleTotals('getLineCoverage');\n    ret.functions = this.computeSimpleTotals('f', 'fnMap');\n    ret.statements = this.computeSimpleTotals('s', 'statementMap');\n    ret.branches = this.computeBranchTotals();\n    return new CoverageSummary(ret);\n  }\n\n} // expose coverage data attributes\n\n\ndataProperties(FileCoverage, ['path', 'statementMap', 'fnMap', 'branchMap', 's', 'f', 'b', 'all']);\nmodule.exports = {\n  FileCoverage\n};","map":{"version":3,"sources":["C:/xampp/htdocs/React DBPMS/node_modules/istanbul-lib-coverage/lib/file-coverage.js"],"names":["percent","require","dataProperties","CoverageSummary","emptyCoverage","filePath","path","statementMap","fnMap","branchMap","s","f","b","assertValidObject","obj","valid","Error","Object","keys","join","FileCoverage","constructor","pathOrObj","data","getLineCoverage","statements","lineMap","create","entries","forEach","st","count","line","start","prevVal","undefined","getUncoveredLines","lc","ret","l","hits","push","getBranchCoverageByLine","branches","k","map","loc","branchData","dataArray","covered","filter","item","coverage","length","total","toJSON","merge","other","all","v","i","retArray","computeSimpleTotals","property","stats","call","values","skipped","pct","computeBranchTotals","resetHits","functions","fill","toSummary","lines","module","exports"],"mappings":"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","sourcesContent":["/*\r\n Copyright 2012-2015, Yahoo Inc.\r\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\r\n */\r\n'use strict';\r\n\r\nconst percent = require('./percent');\r\nconst dataProperties = require('./data-properties');\r\nconst { CoverageSummary } = require('./coverage-summary');\r\n\r\n// returns a data object that represents empty coverage\r\nfunction emptyCoverage(filePath) {\r\n    return {\r\n        path: filePath,\r\n        statementMap: {},\r\n        fnMap: {},\r\n        branchMap: {},\r\n        s: {},\r\n        f: {},\r\n        b: {}\r\n    };\r\n}\r\n\r\n// asserts that a data object \"looks like\" a coverage object\r\nfunction assertValidObject(obj) {\r\n    const valid =\r\n        obj &&\r\n        obj.path &&\r\n        obj.statementMap &&\r\n        obj.fnMap &&\r\n        obj.branchMap &&\r\n        obj.s &&\r\n        obj.f &&\r\n        obj.b;\r\n    if (!valid) {\r\n        throw new Error(\r\n            'Invalid file coverage object, missing keys, found:' +\r\n                Object.keys(obj).join(',')\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * provides a read-only view of coverage for a single file.\r\n * The deep structure of this object is documented elsewhere. It has the following\r\n * properties:\r\n *\r\n * * `path` - the file path for which coverage is being tracked\r\n * * `statementMap` - map of statement locations keyed by statement index\r\n * * `fnMap` - map of function metadata keyed by function index\r\n * * `branchMap` - map of branch metadata keyed by branch index\r\n * * `s` - hit counts for statements\r\n * * `f` - hit count for functions\r\n * * `b` - hit count for branches\r\n */\r\nclass FileCoverage {\r\n    /**\r\n     * @constructor\r\n     * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\r\n     * and empty coverage object with the specified file path or a data object that\r\n     * has all the required properties for a file coverage object.\r\n     */\r\n    constructor(pathOrObj) {\r\n        if (!pathOrObj) {\r\n            throw new Error(\r\n                'Coverage must be initialized with a path or an object'\r\n            );\r\n        }\r\n        if (typeof pathOrObj === 'string') {\r\n            this.data = emptyCoverage(pathOrObj);\r\n        } else if (pathOrObj instanceof FileCoverage) {\r\n            this.data = pathOrObj.data;\r\n        } else if (typeof pathOrObj === 'object') {\r\n            this.data = pathOrObj;\r\n        } else {\r\n            throw new Error('Invalid argument to coverage constructor');\r\n        }\r\n        assertValidObject(this.data);\r\n    }\r\n\r\n    /**\r\n     * returns computed line coverage from statement coverage.\r\n     * This is a map of hits keyed by line number in the source.\r\n     */\r\n    getLineCoverage() {\r\n        const statementMap = this.data.statementMap;\r\n        const statements = this.data.s;\r\n        const lineMap = Object.create(null);\r\n\r\n        Object.entries(statements).forEach(([st, count]) => {\r\n            /* istanbul ignore if: is this even possible? */\r\n            if (!statementMap[st]) {\r\n                return;\r\n            }\r\n            const { line } = statementMap[st].start;\r\n            const prevVal = lineMap[line];\r\n            if (prevVal === undefined || prevVal < count) {\r\n                lineMap[line] = count;\r\n            }\r\n        });\r\n        return lineMap;\r\n    }\r\n\r\n    /**\r\n     * returns an array of uncovered line numbers.\r\n     * @returns {Array} an array of line numbers for which no hits have been\r\n     *  collected.\r\n     */\r\n    getUncoveredLines() {\r\n        const lc = this.getLineCoverage();\r\n        const ret = [];\r\n        Object.entries(lc).forEach(([l, hits]) => {\r\n            if (hits === 0) {\r\n                ret.push(l);\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * returns a map of branch coverage by source line number.\r\n     * @returns {Object} an object keyed by line number. Each object\r\n     * has a `covered`, `total` and `coverage` (percentage) property.\r\n     */\r\n    getBranchCoverageByLine() {\r\n        const branchMap = this.branchMap;\r\n        const branches = this.b;\r\n        const ret = {};\r\n        Object.entries(branchMap).forEach(([k, map]) => {\r\n            const line = map.line || map.loc.start.line;\r\n            const branchData = branches[k];\r\n            ret[line] = ret[line] || [];\r\n            ret[line].push(...branchData);\r\n        });\r\n        Object.entries(ret).forEach(([k, dataArray]) => {\r\n            const covered = dataArray.filter(item => item > 0);\r\n            const coverage = (covered.length / dataArray.length) * 100;\r\n            ret[k] = {\r\n                covered: covered.length,\r\n                total: dataArray.length,\r\n                coverage\r\n            };\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * return a JSON-serializable POJO for this file coverage object\r\n     */\r\n    toJSON() {\r\n        return this.data;\r\n    }\r\n\r\n    /**\r\n     * merges a second coverage object into this one, updating hit counts\r\n     * @param {FileCoverage} other - the coverage object to be merged into this one.\r\n     *  Note that the other object should have the same structure as this one (same file).\r\n     */\r\n    merge(other) {\r\n        if (other.all === true) {\r\n            return;\r\n        }\r\n\r\n        if (this.all === true) {\r\n            this.data = other.data;\r\n            return;\r\n        }\r\n\r\n        Object.entries(other.s).forEach(([k, v]) => {\r\n            this.data.s[k] += v;\r\n        });\r\n        Object.entries(other.f).forEach(([k, v]) => {\r\n            this.data.f[k] += v;\r\n        });\r\n        Object.entries(other.b).forEach(([k, v]) => {\r\n            let i;\r\n            const retArray = this.data.b[k];\r\n            /* istanbul ignore if: is this even possible? */\r\n            if (!retArray) {\r\n                this.data.b[k] = v;\r\n                return;\r\n            }\r\n            for (i = 0; i < retArray.length; i += 1) {\r\n                retArray[i] += v[i];\r\n            }\r\n        });\r\n    }\r\n\r\n    computeSimpleTotals(property) {\r\n        let stats = this[property];\r\n\r\n        if (typeof stats === 'function') {\r\n            stats = stats.call(this);\r\n        }\r\n\r\n        const ret = {\r\n            total: Object.keys(stats).length,\r\n            covered: Object.values(stats).filter(v => !!v).length,\r\n            skipped: 0\r\n        };\r\n        ret.pct = percent(ret.covered, ret.total);\r\n        return ret;\r\n    }\r\n\r\n    computeBranchTotals() {\r\n        const stats = this.b;\r\n        const ret = { total: 0, covered: 0, skipped: 0 };\r\n\r\n        Object.values(stats).forEach(branches => {\r\n            ret.covered += branches.filter(hits => hits > 0).length;\r\n            ret.total += branches.length;\r\n        });\r\n        ret.pct = percent(ret.covered, ret.total);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * resets hit counts for all statements, functions and branches\r\n     * in this coverage object resulting in zero coverage.\r\n     */\r\n    resetHits() {\r\n        const statements = this.s;\r\n        const functions = this.f;\r\n        const branches = this.b;\r\n        Object.keys(statements).forEach(s => {\r\n            statements[s] = 0;\r\n        });\r\n        Object.keys(functions).forEach(f => {\r\n            functions[f] = 0;\r\n        });\r\n        Object.keys(branches).forEach(b => {\r\n            branches[b].fill(0);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * returns a CoverageSummary for this file coverage object\r\n     * @returns {CoverageSummary}\r\n     */\r\n    toSummary() {\r\n        const ret = {};\r\n        ret.lines = this.computeSimpleTotals('getLineCoverage');\r\n        ret.functions = this.computeSimpleTotals('f', 'fnMap');\r\n        ret.statements = this.computeSimpleTotals('s', 'statementMap');\r\n        ret.branches = this.computeBranchTotals();\r\n        return new CoverageSummary(ret);\r\n    }\r\n}\r\n\r\n// expose coverage data attributes\r\ndataProperties(FileCoverage, [\r\n    'path',\r\n    'statementMap',\r\n    'fnMap',\r\n    'branchMap',\r\n    's',\r\n    'f',\r\n    'b',\r\n    'all'\r\n]);\r\n\r\nmodule.exports = {\r\n    FileCoverage\r\n};\r\n"]},"metadata":{},"sourceType":"script"}